'''

 V-Ray/Blender 2.5

 http://vray.cgdo.ru

 Author: Andrey M. Izrantsev (aka bdancer)
 E-Mail: izrantsev@gmail.com

 This plugin is protected by the GNU General Public License v.2

 This program is free software: you can redioutibute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is dioutibuted in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 All Rights Reserved. V-Ray(R) is a registered trademark of Chaos Group

'''


import bpy


FloatProperty= bpy.types.Object.FloatProperty
IntProperty= bpy.types.Object.IntProperty
BoolProperty= bpy.types.Object.BoolProperty
EnumProperty= bpy.types.Object.EnumProperty
VectorProperty= bpy.types.Object.FloatVectorProperty
StringProperty= bpy.types.Object.StringProperty



'''
  Plugin: MtlRenderStats
'''
# TODO



'''
  Plugin: MtlWrapper
'''
BoolProperty(
	attr='vray_node_use_wrapper',
	name='Use wrapper',
	description='Use wrapper options.',
	default= False
)

# base_material: plugin (The base material)
# generate_gi: float (Controls the GI generated by the material.)
FloatProperty(
	attr= 'vb_mwrap_generate_gi',
	name= 'Generate GI',
	description= "Controls the GI generated by the material.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# receive_gi: float (Controls the GI received by the material.)
FloatProperty(
	attr= 'vb_mwrap_receive_gi',
	name= 'Receive GI',
	description= "Controls the GI received by the material.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# generate_caustics: float (Controls the caustics generated by the material.)
FloatProperty(
	attr= 'vb_mwrap_generate_caustics',
	name= 'Generate caustics',
	description= "Controls the caustics generated by the material.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# receive_caustics: float (Controls the caustics received by the material.)
FloatProperty(
	attr= 'vb_mwrap_receive_caustics',
	name= 'Receive caustics',
	description= "Controls the caustics received by the material.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# alpha_contribution: float (The contribution of the resulting color to the alpha channel.)
FloatProperty(
	attr= 'vb_mwrap_alpha_contribution',
	name= 'Alpha contribution',
	description= "The contribution of the resulting color to the alpha channel.",
	min= -1.0,
	max= 1.0,
	soft_min= -1.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# matte_surface: bool (Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.)
BoolProperty(
	attr= 'vb_mwrap_matte_surface',
	name= 'Matte surface',
	description= "Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.",
	default= False
)

# shadows: bool (Turn this on to make shadow visible on the matter surface.)
BoolProperty(
	attr= 'vb_mwrap_shadows',
	name= 'Shadows',
	description= "Turn this on to make shadow visible on the matter surface.",
	default= False
)

# affect_alpha: bool (Turn this on to make shadows affect the alpha contribution of the matte surface.)
BoolProperty(
	attr= 'vb_mwrap_affect_alpha',
	name= 'Affect alpha',
	description= "Turn this on to make shadows affect the alpha contribution of the matte surface.",
	default= False
)

# shadow_tint_color: color (Tint for the shadows on the matte surface.) = Color(0, 0, 0)
VectorProperty( 
	attr= "vb_mwrap_shadow_tint_color", 
	name= "Shadow tint color", 
	description= 'Tint for the shadows on the matte surface.', 
	subtype= "COLOR", 
	min= 0.0, 
	max= 1.0, 
	soft_min= 0.0, 
	soft_max= 1.0, 
	default= (0.0, 0.0, 0.0)
)

# shadow_brightness: float (An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.)
FloatProperty(
	attr= 'vb_mwrap_shadow_brightness',
	name= 'Shadow brightness',
	description= "An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# reflection_amount: float (Shows the reflections of the base material.)
FloatProperty(
	attr= 'vb_mwrap_reflection_amount',
	name= 'Reflection amount',
	description= "Shows the reflections of the base material.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# refraction_amount: float (Shows the refractions of the base material.)
FloatProperty(
	attr= 'vb_mwrap_refraction_amount',
	name= 'Refraction amount',
	description= "Shows the refractions of the base material.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# gi_amount: float (Determines the amount of gi shadows.)
FloatProperty(
	attr= 'vb_mwrap_gi_amount',
	name= 'GI amount',
	description= "Determines the amount of gi shadows.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# no_gi_on_other_mattes: bool (This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.)
BoolProperty(
	attr= 'vb_mwrap_no_gi_on_other_mattes',
	name= 'No gi on other mattes',
	description= "This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.",
	default= True
)

# matte_for_secondary_rays: bool (Turn this on to make the material act as matte for all secondary rays (reflections, refractions, etc))
BoolProperty(
	attr= 'vb_mwrap_matte_for_sec_rays',
	name= 'Matte for secondary rays',
	description= "Turn this on to make the material act as matte for all secondary rays (reflections, refractions, etc)",
	default= False
)

# gi_surface_id: integer (If two objects have different GI surface ids, the light cache samples of the two objects will not be blended)
IntProperty(
	attr= 'vb_mwrap_gi_surface_id',
	name= 'GI surface id',
	description= "If two objects have different GI surface ids, the light cache samples of the two objects will not be blended",
	min= 0,
	max= 10,
	default= 0
)

# gi_quality_multiplier: float (A multiplier for GI quality)
FloatProperty(
	attr= 'vb_mwrap_gi_quality_multiplier',
	name= 'GI quality multiplier',
	description= "A multiplier for GI quality",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

# alpha_contribution_tex: float texture (Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution) = 1
# shadow_brightness_tex: float texture (Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness) = 1
# reflection_filter_tex: acolor texture = AColor(1, 1, 1, 1)

# trace_depth: integer (The maximum reflection depth (-1 is controlled by the global options))
IntProperty(
	attr= 'vb_mwrap_trace_depth',
	name= 'Trace depth',
	description= "The maximum reflection depth (-1 is controlled by the global options)",
	min= -1,
	max= 1000,
	default= -1
)

# channels: plugin (Render channels the result of this BRDF will be written to), unlimited list


'''
  Plugin: LightMesh
'''
BoolProperty(
	attr= "vray_node_meshlight",
	name= "Mesh-light",
	description= "Mesh is mesh-light.",
	options={'HIDDEN'},
	default= False
)

EnumProperty(
	attr="vray_lamp_units",
	name="Intensity units",
	description="Units for the intensity.",
	items=(
		('DEFUALT',  "Default",   ""),
		('LUMENS',   "Lumens",    ""),
		('LUMM',     "Lm/m/m/sr", ""),
		('WATTSM',   "Watts",     ""),
		('WATM',     "W/m/m/sr", "")
	),
	default= 'DEFAULT'
)

BoolProperty(
	attr="vray_lamp_enabled",
	name="Enabled",
	description="Turns the light on and off",
	default= True
)

BoolProperty(
	attr= "vray_lamp_shadows",
	name= "Shadows",
	description= "TODO.",
	default= True
)

BoolProperty(
	attr= "vray_lamp_affectDiffuse",
	name= "Affect diffuse",
	description= "Produces diffuse lighting.",
	default= True
)

BoolProperty(
	attr= "vray_lamp_affectSpecular",
	name= "Affect specular",
	description= "Produces specular hilights.",
	default= True
)

BoolProperty(
	attr= "vray_lamp_affectReflections",
	name= "Affect reflections",
	description= "Appear in reflections.",
	default= False
)

VectorProperty(
	attr= "vray_lamp_shadowColor",
	name= "Shadow color",
	description= "The shadow color. Anything but black is not physically accurate.",
	subtype= "COLOR",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	default= (0.0,0.0,0.0)
)

FloatProperty(
	attr= "vray_lamp_shadowBias",
	name= "Shadow bias",
	description= "Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 0.0
)

IntProperty(
	attr= "vray_lamp_shadowSubdivs",
	name= "Shadow subdivs",
	description= "TODO.",
	min= 0,
	max= 10,
	default= 8
)

FloatProperty(
	attr= "vray_lamp_shadowRadius",
	name= "Shadow radius",
	description= "TODO.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 0
)

FloatProperty(
	attr= "vray_lamp_decay",
	name= "Decay",
	description= "TODO.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 2
)

FloatProperty(
	attr= "vray_lamp_cutoffThreshold",
	name= "Cut-off threshold",
	description= "Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed..",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 0.1,
	precision= 3,
	default= 0.001
)

FloatProperty(
	attr= "vray_lamp_intensity",
	name= "Intensity",
	description= "Light intensity.",
	min= 0.0,
	max= 10000000.0,
	soft_min= 0.0,
	soft_max= 100.0,
	precision= 2,
	default= 30
)

IntProperty(
	attr= "vray_lamp_subdivs",
	name= "Subdivs",
	description= "TODO.",
	min= 0,
	max= 10,
	default= 8
)

BoolProperty(
	attr= "vray_lamp_storeWithIrradianceMap",
	name= "Store with irradiance map",
	description= "TODO.",
	default= False
)

BoolProperty(
	attr= "vray_lamp_invisible",
	name= "Invisible",
	description= "TODO.",
	default= False
)

BoolProperty(
	attr= "vray_lamp_noDecay",
	name= "No decay",
	description= "TODO.",
	default= False
)

BoolProperty(
	attr= "vray_lamp_doubleSided",
	name= "Double-sided",
	description= "TODO.",
	default= False
)

EnumProperty(
	attr="vray_lamp_portal_mode",
	name="Light portal mode",
	description="Specifies if the light is a portal light.",
	items=(
		('NORMAL',  "Normal light",   ""),
		('PORTAL',  "Portal",         ""),
		('SPORTAL', "Simple portal",  "")
	),
	default= 'NORMAL'
)

BoolProperty(
	attr= "vray_lamp_bumped_below_surface_check",
	name= "Bumped below surface check",
	description= "If the bumped normal should be used to check if the light dir is below the surface.",
	default= False
)

IntProperty(
	attr= "vray_lamp_nsamples",
	name= "Motion blur samples",
	description= "Motion blur samples.",
	min= 0,
	max= 10,
	default= 0
)

FloatProperty(
	attr= "vray_lamp_diffuse_contribution",
	name= "Diffuse contribution",
	description= "TODO.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

FloatProperty(
	attr= "vray_lamp_specular_contribution",
	name= "Specular contribution",
	description= "TODO.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)

IntProperty(
	attr= "vray_lamp_causticSubdivs",
	name= "Causticsubdivs",
	description= "TODO.",
	min= 0,
	max= 10,
	default= 1000
)

FloatProperty(
	attr= "vray_lamp_causticMult",
	name= "Causticmult",
	description= "TODO.",
	min= 0.0,
	max= 1.0,
	soft_min= 0.0,
	soft_max= 1.0,
	precision= 3,
	default= 1
)


# shadowColor: color (The shadow color. Anything but black is not physically accurate.) = Color(0, 0, 0)
# shadowColor_tex: acolor texture (A color texture that if present will override the shadowColor parameter)
# channels: plugin (Render channels the result of this light will be written to), unlimited list
# channels_raw: plugin (Render channels the raw diffuse result of this light will be written to), unlimited list
# channels_diffuse: plugin (Render channels the diffuse result of this light will be written to), unlimited list
# channels_specular: plugin (Render channels the specular result of this light will be written to), unlimited list

# tex: acolor texture (The light texture)

# use_tex: bool (true if the texture should be used)
BoolProperty(
	attr= 'vray_lamp_use_tex',
	name= 'use_tex',
	description= "TODO.",
	default= False
)

# tex_resolution: integer (The internal texture resolution)
IntProperty(
	attr= 'vray_lamp_tex_resolution',
	name= 'tex_resolution',
	description= "TODO.",
	min= 0,
	max= 10,
	default= 256
)

# cache_tex: bool (When this is true the texture will be cached at tex_resolution x tex_resolution and this cached texture will be used to determine the texture color for shadows rays(speeding up light evaluation, especially for complex procedural textures))
BoolProperty(
	attr= 'vray_lamp_cache_tex',
	name= 'cache_tex',
	description= "TODO.",
	default= True
)



'''
  Plugin: GeomMeshFile
'''
BoolProperty(
	attr="vray_proxy",
	name="Proxy",
	description="",
	default= False
)

StringProperty(
	attr="vray_proxy_file",
	name="File",
	subtype= 'FILE_PATH',
	description="Proxy file."
)

EnumProperty(
	attr="vray_proxy_anim_type",
	name="Animation type",
	description="This determines the type of BRDF (the shape of the hilight).",
	items=(("LOOP",     "Loop",      "TODO."),
		   ("ONCE",     "Once",      "TODO."),
		   ("PINGPONG", "Ping-pong", "TODO."),
		   ("STILL",    "Still",     "TODO.")),
	default= "LOOP"
)

FloatProperty(
	attr="vray_proxy_anim_speed",
	name="Speed",
	description="Animated proxy playback speed.",
	min=0.0, max=1000.0,
	soft_min=0.0, soft_max=1.0,
	default= 1.0
)

FloatProperty(
	attr="vray_proxy_anim_offset",
	name="Offset",
	description="Animated proxy initial frame offset.",
	min=0.0, max=1000.0, soft_min=0.0, soft_max=1.0, default= 0.0
)



'''
  GUI
'''
import properties_data_mesh
properties_data_mesh.DATA_PT_context_mesh.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_normals.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_settings.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_shape_keys.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_texface.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_uv_texture.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_vertex_colors.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.DATA_PT_vertex_groups.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.MESH_MT_shape_key_specials.COMPAT_ENGINES.add('VRAY_RENDER')
properties_data_mesh.MESH_MT_vertex_group_specials.COMPAT_ENGINES.add('VRAY_RENDER')
del properties_data_mesh


class DataButtonsPanelEmpty(bpy.types.Panel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'data'

	def poll(self, context):
		engine= context.scene.render.engine
		return (context.mesh or (context.object and context.object.type == 'EMPTY')) and (engine in self.COMPAT_ENGINES)


class DataButtonsPanel(bpy.types.Panel):
	bl_space_type  = 'PROPERTIES'
	bl_region_type = 'WINDOW'
	bl_context     = 'data'

	def poll(self, context):
		engine= context.scene.render.engine
		return (context.mesh) and (engine in self.COMPAT_ENGINES)


class DATA_PT_vray_wrapper(DataButtonsPanel):
	bl_label = "Wrapper"
	bl_default_closed = True

	COMPAT_ENGINES = {'VRAY_RENDER'}

	def draw_header(self, context):
		ob= context.object
		self.layout.prop(ob, "vray_node_use_wrapper", text="")

	def draw(self, context):
		ob= context.object
		me= context.mesh

		layout= self.layout
		layout.active= ob.vray_node_use_wrapper

		wide_ui= context.region.width > 200

		split= layout.split()
		col= split.column()
		col.prop(ob, 'vb_mwrap_generate_gi')
		col.prop(ob, 'vb_mwrap_receive_gi')
		if(wide_ui):
			col= split.column()
		col.prop(ob, 'vb_mwrap_generate_caustics')
		col.prop(ob, 'vb_mwrap_receive_caustics')

		split= layout.split()
		col= split.column()
		col.prop(ob, 'vb_mwrap_gi_quality_multiplier')

		split= layout.split()
		col= split.column()
		col.label(text="Matte properties")

		split= layout.split()
		colL= split.column()
		colL.prop(ob, 'vb_mwrap_matte_surface')
		if(wide_ui):
			colR= split.column()
		else:
			colR= colL
		colR.prop(ob, 'vb_mwrap_alpha_contribution')
		if(ob.vb_mwrap_matte_surface):
			colR.prop(ob, 'vb_mwrap_reflection_amount')
			colR.prop(ob, 'vb_mwrap_refraction_amount')
			colR.prop(ob, 'vb_mwrap_gi_amount')
			colR.prop(ob, 'vb_mwrap_no_gi_on_other_mattes')

			colL.prop(ob, 'vb_mwrap_affect_alpha')
			colL.prop(ob, 'vb_mwrap_shadows')
			if(ob.vb_mwrap_shadows):
				colL.prop(ob, 'vb_mwrap_shadow_tint_color')
				colL.prop(ob, 'vb_mwrap_shadow_brightness')
			
		#col.prop(ob, 'vb_mwrap_alpha_contribution_tex')
		#col.prop(ob, 'vb_mwrap_shadow_brightness_tex')
		#col.prop(ob, 'vb_mwrap_reflection_filter_tex')

		split= layout.split()
		col= split.column()
		col.label(text="Miscellaneous")

		split= layout.split()
		col= split.column()
		col.prop(ob, 'vb_mwrap_gi_surface_id')
		col.prop(ob, 'vb_mwrap_trace_depth')
		if(wide_ui):
			col= split.column()
		col.prop(ob, 'vb_mwrap_matte_for_sec_rays')



class DATA_PT_vray_proxy(DataButtonsPanelEmpty):
	bl_label = "Proxy"
	bl_default_closed = True
	
	COMPAT_ENGINES = set(['VRAY_RENDER'])

	def draw_header(self, context):
		ob= context.object
		self.layout.prop(ob, "vray_proxy", text="")

	def draw(self, context):
		layout= self.layout

		wide_ui= context.region.width > 200

		ob= context.object

		layout.active= ob.vray_proxy

		split= layout.split()
		colL= split.column()
		colL.prop(ob, "vray_proxy_file")

		split= layout.split()
		col= split.column()
		col.prop(ob, "vray_proxy_anim_type")

		split= layout.split()
		col= split.column()
		col.prop(ob, "vray_proxy_anim_speed")
		if(wide_ui):
			col= split.column()
		col.prop(ob, "vray_proxy_anim_offset")


bpy.types.register(DATA_PT_vray_proxy)
bpy.types.register(DATA_PT_vray_wrapper)
